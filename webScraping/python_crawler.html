<!DOCTYPE html>
<html>
<head>
	<title>网络数据采集</title>
	<meta charset="utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<link rel="stylesheet" type="text/css" href="../css/index.css">
</head>
<body>
<header>
	<div class="info">
		<div class="blog-photo"><img src="../images/me.jpg"></div>
		<div class="blog-intro">
			<p class="blog-name">初木禾君</p>
			<p class="blog-university">Tianjin University</p>
		</div>
	</div>
</header>
<div class="container">
	<h1>利用python和正则表达式采集网络数据</h1>
	<article>
		<h2>获取segmentfault推荐的博客标题</h2>
		<p>
			<pre>
    #by zhangtao
    #coding:utf-8
    import urllib
    import urllib2
    import re
    url = "https://segmentfault.com/blogs"
    headers = { 'Host' : 'segmentfault.com',
                'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1; WOW64) 
                                AppleWebKit/537.36 (KHTML, like Gecko) 
                                Chrome/50.0.2661.102 Safari/537.36',
                 'Referer':'https://segmentfault.com/blogs'} 
    #构建请求的request
    request = urllib2.Request(url=url,headers=headers)
    #利用urlopen获取页面代码
    response = urllib2.urlopen(request)
    #利用正则表达式确定匹配
    pattern = re.compile(' &lt;h2 class="title"&gt;&lt;a href="/a/.*?"&gt;(.*?)&lt;/a&gt;&lt;/h2&gt;',re.S)
    #找出所有的符合该模式的语句
    items = re.findall(pattern,response.read())
    #遍历输出
    for item in items:
    	print item
    	print 
			</pre>
		</p>
	</article>
	<article>
		<h2>获取稀土掘金前端推荐的博客标题</h2>
		<p>
			<pre>
	#by zhangtao
	#coding:utf-8
	import urllib
	import urllib2
	import re
	url = "http://gold.xitu.io/welcome/frontend"
	headers = { 'Host' : 'gold.xitu.io',
		    'User-Agent' : 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)',
		    'Referer':'http://gold.xitu.io/welcome/frontend' } 
	#构建请求的request
	request = urllib2.Request(url=url,headers=headers)
	#利用urlopen获取页面代码
	response = urllib2.urlopen(request)
	#利用正则表达式确定匹配
	pattern = re.compile('&lt;div class="entry-title ellipsis"&gt;(.*?)&lt;/div&gt;',re.S)
	#找出所有的符合该模式的语句
	items = re.findall(pattern,response.read())
	#遍历输出
	for item in items:
		print item
		print 
			</pre>
		</p>
	</article>
	<article>
		<h2>获取糗事百科段子</h2>
		<p>
			<pre>
#-*- coding:utf-8 -*-
import urllib
import urllib2
import re
import thread
import time

#糗事百科爬虫类
class QSBK:

	#初始化方法，定义一些变量
	def __init__(self):
		self.pageIndex = 1
		self.user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'
		#初始化headers
		self.headers = { 'User-Agent' : self.user_agent }
		#存放段子的变量，每一个元素是每一页的段子们
		self.stories = []
		#存放程序是否继续运行的变量
		self.enable = False
		#传入某一页的索引获得页面代码
	def getPage(self,pageIndex):
		try:
			url = 'http://www.qiushibaike.com/hot/page/' + str(pageIndex)
			#构建请求的request
			request = urllib2.Request(url,headers = self.headers)
			#利用urlopen获取页面代码
			response = urllib2.urlopen(request)
			#将页面转化为UTF-8编码
			pageCode = response.read().decode('utf-8')
			return pageCode
	
		except urllib2.URLError, e:
			if hasattr(e,"reason"):
				print u"连接糗事百科失败,错误原因",e.reason
				return None
	

	#传入某一页代码，返回本页不带图片的段子列表
	def getPageItems(self,pageIndex):
		pageCode = self.getPage(pageIndex)
		if not pageCode:
			print "页面加载失败...."
			return None
		pattern = re.compile('<div class="author clearfix">.*?href.*?<img src.*?title=.*?<h2>(.*?)</h2>.*?<div class="content">(.*?)</div>.*?<i class="number">(.*?)</i>',re.S)
		items = re.findall(pattern,pageCode)
		#用来存储每页的段子们
		pageStories = []
		#遍历正则表达式匹配的信息
		for item in items:
			replaceBR = re.compile('<br/>')
			text = re.sub(replaceBR,"\n",item [1] )
			print item[0],text ,item [2]
			pageStories.append([item[0].strip(),text.strip(),item [2] .strip()])
		return pageStories
	
	#加载并提取页面的内容，加入到列表中
	def loadPage(self):
		#如果当前未看的页数少于2页，则加载新一页
		if self.enable == True:
			if len(self.stories) < 2:
				#获取新一页
				pageStories = self.getPageItems(self.pageIndex)
				#将该页的段子存放到全局list中
				if pageStories:
					self.stories.append(pageStories)
					#获取完之后页码索引加一，表示下次读取下一页
					self.pageIndex += 1
	
	#调用该方法，每次敲回车打印输出一个段子
	def getOneStory(self,pageStories,page):
		#遍历一页的段子
		for story in pageStories:
			#等待用户输入
			input = raw_input()
			#每当输入回车一次，判断一下是否要加载新页面
			self.loadPage()
			#如果输入Q则程序结束
			if input == "Q":
				self.enable = False
				return
			print u"第%d页\t发布人:%s\t赞:%s\n%s" %(page,story[0],story [2] ,story [1] )
	
	#开始方法
	def start(self):
		print u"正在读取糗事百科,按回车查看新段子，Q退出"
		#使变量为True，程序可以正常运行
		self.enable = True
		#先加载一页内容
		self.loadPage()
		#局部变量，控制当前读到了第几页
		nowPage = 0
		while self.enable:
			if len(self.stories)>0:
				#从全局list中获取一页的段子
				pageStories = self.stories[0]
				#当前读到的页数加一
				nowPage += 1
				#将全局list中第一个元素删除，因为已经取出
				del self.stories[0]
				#输出该页的段子
				self.getOneStory(pageStories,nowPage)
	
	
spider = QSBK()
spider.start()
			</pre>
		</p>
	</article>
</div>
</body>
</html>